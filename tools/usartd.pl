use warnings;
use strict;
use IO::Socket::UNIX;
use IO::Select;

my $BOOTLOADERS = {
	ServiceMode => [
		0xF1, 0x04, 0xA0, 0xE3, 0x20, 0x10, 0x90, 0xE5, 0xFF, 0x10, 0xC1, 0xE3, 0xA5, 0x10, 0x81, 0xE3,
		0x20, 0x10, 0x80, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x53, 0x49, 0x45, 0x4D, 0x45, 0x4E, 0x53, 0x5F, 0x42, 0x4F, 0x4F, 0x54, 0x43, 0x4F, 0x44, 0x45,
		
		0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x01, 0x04, 0x05, 0x00, 0x8B, 0x00, 0x8B		# service mode
	],
	BurninMode => [
		0xF1, 0x04, 0xA0, 0xE3, 0x20, 0x10, 0x90, 0xE5, 0xFF, 0x10, 0xC1, 0xE3, 0xA5, 0x10, 0x81, 0xE3,
		0x20, 0x10, 0x80, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x53, 0x49, 0x45, 0x4D, 0x45, 0x4E, 0x53, 0x5F, 0x42, 0x4F, 0x4F, 0x54, 0x43, 0x4F, 0x44, 0x45,
		
		0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		
		0x01, 0x04, 0x05, 0x80, 0x83, 0x00, 0x03		# burnin mode
	],
	NormalMode => [
		0xF1, 0x04, 0xA0, 0xE3, 0x20, 0x10, 0x90, 0xE5, 0xFF, 0x10, 0xC1, 0xE3, 0xA5, 0x10, 0x81, 0xE3,
		0x20, 0x10, 0x80, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x53, 0x49, 0x45, 0x4D, 0x45, 0x4E, 0x53, 0x5F, 0x42, 0x4F, 0x4F, 0x54, 0x43, 0x4F, 0x44, 0x45,
		
		0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		
		0x01, 0x04, 0x05, 0x00, 0x89, 0x00, 0x89		# normal mode
	]
};

my $SOCK_PATH = "/tmp/siemens.sock";

unlink $SOCK_PATH if -e $SOCK_PATH;

my $server = IO::Socket::UNIX->new(
	Type		=> SOCK_STREAM(),
	Local		=> $SOCK_PATH,
	Listen		=> 1,
	Blocking	=> 1
) or die("socket: $!");

while (my $client = $server->accept()) {
	$client->blocking(0);
	processClient($client);
}

sub processClient {
	my ($client) = @_;
	
	my $select = new IO::Select;
	$select->add($client);
	
	my $rx;
	
	if ($select->can_write(1)) {
		$client->send("ATAT");
	} else {
		print "Timeout...\n";
		return;
	}
	
	if ($select->can_read(1)) {
		$client->recv($rx, 1);
		if ($rx eq "\xC0" || $rx eq "\xB0") {
			print "Device: NewSGOLD\n" if ($rx eq "\xC0");
			print "Device: SGOLD\n" if ($rx eq "\xB0");
		} else {
			print "Unknown response  ".sprintf("%02X", ord($rx))."\n";
			return;
		}
	} else {
		print "Timeout...\n";
		return;
	}
	
	for my $c (mkBootCode($ARGV[0] || 'ServiceMode')) {
		if ($select->can_write(1)) {
			$client->send(chr($c));
		}
	}
	
	if ($select->can_read(1)) {
		$client->recv($rx, 1);
		if ($rx eq "\xC1" || $rx eq "\xB1") {
			print "Boot code loaded.\n";
		} else {
			print "Unknown response: ".sprintf("%02X", ord($rx))."\n";
			return;
		}
	} else {
		print "Timeout...\n";
		return;
	}
	
	while ($client->opened) {
		if ($select->can_read(1)) {
			$client->recv($rx, 1);
			last if !length($rx);
			
			if ($rx =~ /[^\t\n\x20-x7e]/) {
				print "\n" if (ord($rx) == 0xFF);
			} else {
				print $rx;
			}
		}
	}
	
	print "Disconnected!\n";
}

sub mkBootCode {
	my ($name) = @_;
	
	my $boot = $BOOTLOADERS->{$name};
	my $len = scalar(@$boot);
	
	my @payload = (0x30, $len & 0xFF, ($len >> 8) & 0xFF);
	
	# XOR
	my $chk = 0;
	for (my $i = 0; $i < $len; ++$i) {
		my $c = $boot->[$i];
		$chk ^= $c;
		push @payload, $c;
	}
	
	push @payload, $chk;
	
	return @payload;
}
