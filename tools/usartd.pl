#!/usr/bin/env perl
use warnings;
use strict;
use IO::Socket::UNIX;
use IO::Select;
use Time::HiRes;

my $BOOTLOADERS = {
	ServiceMode => [
		0xF1, 0x04, 0xA0, 0xE3, 0x20, 0x10, 0x90, 0xE5, 0xFF, 0x10, 0xC1, 0xE3, 0xA5, 0x10, 0x81, 0xE3,
		0x20, 0x10, 0x80, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x53, 0x49, 0x45, 0x4D, 0x45, 0x4E, 0x53, 0x5F, 0x42, 0x4F, 0x4F, 0x54, 0x43, 0x4F, 0x44, 0x45,
		
		0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x01, 0x04, 0x05, 0x00, 0x8B, 0x00, 0x8B		# service mode
	],
	BurninMode => [
		0xF1, 0x04, 0xA0, 0xE3, 0x20, 0x10, 0x90, 0xE5, 0xFF, 0x10, 0xC1, 0xE3, 0xA5, 0x10, 0x81, 0xE3,
		0x20, 0x10, 0x80, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x53, 0x49, 0x45, 0x4D, 0x45, 0x4E, 0x53, 0x5F, 0x42, 0x4F, 0x4F, 0x54, 0x43, 0x4F, 0x44, 0x45,
		
		0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		
		0x01, 0x04, 0x05, 0x80, 0x83, 0x00, 0x03		# burnin mode
	],
	NormalMode => [
		0xF1, 0x04, 0xA0, 0xE3, 0x20, 0x10, 0x90, 0xE5, 0xFF, 0x10, 0xC1, 0xE3, 0xA5, 0x10, 0x81, 0xE3,
		0x20, 0x10, 0x80, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x53, 0x49, 0x45, 0x4D, 0x45, 0x4E, 0x53, 0x5F, 0x42, 0x4F, 0x4F, 0x54, 0x43, 0x4F, 0x44, 0x45,
		
		0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		
		0x01, 0x04, 0x05, 0x00, 0x89, 0x00, 0x89		# normal mode
	]
};

my $SOCK_PATH = "/tmp/siemens.sock";

unlink $SOCK_PATH if -e $SOCK_PATH;

my $server = IO::Socket::UNIX->new(
	Type		=> SOCK_STREAM(),
	Local		=> $SOCK_PATH,
	Listen		=> 1,
	Blocking	=> 1
) or die("socket: $!");

while (my $client = $server->accept()) {
	$client->blocking(0);
	processClient($client);
	print "-> disconnected\n";
}

sub processClient {
	my ($client) = @_;
	
	my $select = new IO::Select;
	$select->add($client);
	
	print "-> connected new client, sending AT\n";
	
	while (1) {
		$client->send("ATAT");
		
		my $ack = readFromSock($select, 1, 0.2);
		return if !defined $ack;
		
		if ($ack eq "\xC0" || $ack eq "\xB0") {
			print "-> device: NewSGOLD\n" if ($ack eq "\xC0");
			print "-> device: SGOLD\n" if ($ack eq "\xB0");
			last;
		}
	}
	
	for my $c (mkBootCode($ARGV[0] || 'ServiceMode')) {
		if ($select->can_write(3)) {
			$client->send(chr($c));
		} else {
			print "-> write timeout\n";
			last;
		}
	}
	
	my $ack = readFromSock($select, 1, 2);
	return if !defined $ack;
	
	if ($ack eq "\xC1" || $ack eq "\xB1") {
		print "-> boot code loaded.\n";
	} else {
		print "-> unknown response: ".sprintf("%02X", ord($ack))."\n";
	}
	
	while ($client->opened) {
		my $c = readFromSock($select, 1, 2);
		return if !defined $c;
		
		if ($c =~ /[^\t\n\x20-x7e]/) {
			print "\n" if (ord($c) == 0xFF);
		} else {
			print $c;
		}
	}
	
	print "Disconnected!\n";
}

sub readFromSock {
	my ($select, $size, $timeout) = @_;
	
	my $end = Time::HiRes::time + $timeout;
	my $readed = 0;
	my $data = "";
	
	while ($readed < $size) {
		my $new_timeout = $timeout - ($end - Time::HiRes::time);
		
		last if ($new_timeout <= 0);
		
		my @fp = $select->can_read($new_timeout);
		if (@fp) {
			my $rx;
			
			my $ret = sysread $fp[0], $rx, $size - $readed;
			return undef if !$ret;
			
			$readed += $ret;
			$data .= $rx;
		}
	}
	
	return $data;
}

sub mkBootCode {
	my ($name) = @_;
	
	my $boot = $BOOTLOADERS->{$name};
	if (!$boot) {
		$boot = [];
		
		open(F, "<", $name) or die "open($name): $!";
		while (!eof(F)) {
			read F, my $chunk, 4096;
			
			for (my $i = 0; $i < length($chunk); $i++) {
				push @$boot, ord(substr($chunk, $i, 1));
			}
		}
		close F;
	}
	
	my $len = scalar(@$boot);
	
	print "-> boot: $name [$len bytes]\n";
	
	my @payload = (0x30, $len & 0xFF, ($len >> 8) & 0xFF);
	
	# XOR
	my $chk = 0;
	for (my $i = 0; $i < $len; ++$i) {
		my $c = $boot->[$i];
		$chk ^= $c;
		push @payload, $c;
	}
	
	push @payload, $chk;
	
	return @payload;
}
